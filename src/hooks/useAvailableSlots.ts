import { useState, useEffect } from 'react';
import { generateTimeSlots, isWithinBusinessHours, holidays } from '@/config/businessHours';
import type { DayConfig } from '@/config/businessHours';
import { toast } from 'sonner';

interface UseAvailableSlotsProps {
  selectedDate: Date;
  dayConfig: DayConfig;
}

interface AppointmentResponse {
  data: Array<{ scheduled_at: string; status: string }>;
  count: number;
  range?: {
    start: string;
    end: string;
  };
  error?: string;
  details?: string;
  message?: string;
  retry?: boolean;
}

export function useAvailableSlots({ selectedDate, dayConfig }: UseAvailableSlotsProps) {
  const [availableSlots, setAvailableSlots] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;
    let retryAttempt = 0;
    const MAX_RETRIES = 2;
    const RETRY_DELAY = 1500; // 1.5 segundos

    async function generateAvailableSlots(bookedTimes: string[] = []) {
      if (!isMounted) return;

      try {
        // 1. Gerar todos os hor√°rios poss√≠veis
        const allTimeSlots = generateTimeSlots(dayConfig);
        console.log('‚ú® Hor√°rios gerados:', allTimeSlots.length);

        // 2. Remover hor√°rios ocupados
        let availableTimes = allTimeSlots.filter(time => !bookedTimes.includes(time));
        console.log('üïí Hor√°rios dispon√≠veis iniciais:', availableTimes.length);

        // 3. Filtrar hor√°rios passados se for hoje
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const selectedDay = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate());

        if (selectedDay.getTime() === today.getTime()) {
          const currentHour = now.getHours();
          const currentMinutes = now.getMinutes();
          const marginMinutes = currentMinutes + 30;
          const marginHour = currentHour + Math.floor(marginMinutes / 60);
          const adjustedMinutes = marginMinutes % 60;

          availableTimes = availableTimes.filter(time => {
            const [hours, minutes] = time.split(':').map(Number);
            return hours > marginHour || (hours === marginHour && minutes > adjustedMinutes);
          });
          console.log('‚è∞ Hor√°rios ap√≥s filtro de hora atual:', availableTimes.length);
        }

        // 4. Verificar hor√°rios dentro do per√≠odo de funcionamento
        availableTimes = availableTimes.filter(time => isWithinBusinessHours(time, dayConfig));
        console.log('üìÖ Hor√°rios dentro do per√≠odo de funcionamento:', availableTimes.length);

        // 5. Atualizar estado
        if (availableTimes.length === 0) {
          setError('N√£o h√° hor√°rios dispon√≠veis para esta data');
        } else {
          setAvailableSlots(availableTimes);
          setError(null);
        }
      } catch (err) {
        console.error('‚ùå Erro ao gerar hor√°rios:', err);
        setError('Erro ao processar hor√°rios dispon√≠veis');
        setAvailableSlots([]);
      }
    }

    async function fetchBookedSlots() {
      if (!selectedDate || !dayConfig) {
        console.error('‚ùå Data ou configura√ß√£o do dia n√£o fornecida');
        setError('Dados inv√°lidos');
        setIsLoading(false);
        return;
      }

      try {
        setIsLoading(true);
        setError(null);

        // 1. Verificar se √© feriado
        const dateString = selectedDate.toISOString().split('T')[0];
        console.log('üìÖ Verificando data:', dateString);

        if (holidays.includes(dateString)) {
          console.log('üèñÔ∏è √â feriado - retornando lista vazia');
          setAvailableSlots([]);
          setIsLoading(false);
          return;
        }

        // 2. Verificar se estabelecimento est√° aberto
        if (!dayConfig.isOpen) {
          console.log('üîí Estabelecimento fechado - retornando lista vazia');
          setAvailableSlots([]);
          setIsLoading(false);
          return;
        }

        // 3. Tentar buscar agendamentos
        const startDate = `${dateString}T00:00:00`;
        const endDate = `${dateString}T23:59:59`;
        
        console.log(`üîÑ Buscando agendamentos (tentativa ${retryAttempt + 1}/${MAX_RETRIES + 1}):`, 
          { startDate, endDate });

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        try {
          const response = await fetch(
            `/api/appointments?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}`,
            { signal: controller.signal }
          );

          clearTimeout(timeoutId);
          const responseData: AppointmentResponse = await response.json();

          // 4. Tratar resposta da API
          if (!response.ok) {
            console.warn('‚ö†Ô∏è Resposta n√£o-ok da API:', {
              status: response.status,
              retry: responseData.retry,
              attempt: retryAttempt + 1
            });

            // Se for erro 503 ou retry e ainda temos tentativas
            if ((response.status === 503 || responseData.retry) && retryAttempt < MAX_RETRIES) {
              retryAttempt++;
              const delay = RETRY_DELAY * retryAttempt;
              console.log(`üîÑ Aguardando ${delay}ms para tentar novamente...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              await fetchBookedSlots();
              return;
            }

            // Se acabaram as tentativas, usar fallback
            console.log('‚ö†Ô∏è M√°ximo de tentativas atingido - usando fallback com hor√°rios vazios');
            await generateAvailableSlots([]);
            return;
          }

          // 5. Processar dados recebidos
          const bookedSlots = responseData.data || [];
          console.log(`‚úÖ Agendamentos encontrados: ${bookedSlots.length}`);

          const bookedTimes = bookedSlots.map(slot => {
            const date = new Date(slot.scheduled_at);
            return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
          });

          // 6. Gerar hor√°rios dispon√≠veis
          await generateAvailableSlots(bookedTimes);

        } catch (fetchError) {
          console.error('‚ùå Erro na requisi√ß√£o:', fetchError);
          
          if (fetchError instanceof Error) {
            if (fetchError.name === 'AbortError') {
              console.warn('‚è±Ô∏è Timeout na requisi√ß√£o');
              if (retryAttempt < MAX_RETRIES) {
                retryAttempt++;
                console.log(`üîÑ Tentando novamente ap√≥s timeout (${retryAttempt}/${MAX_RETRIES})`);
                await fetchBookedSlots();
                return;
              }
            }
          }

          // Fallback em caso de erro
          console.log('‚ö†Ô∏è Usando fallback ap√≥s erro na requisi√ß√£o');
          await generateAvailableSlots([]);
        }
      } catch (err) {
        console.error('‚ùå Erro n√£o tratado:', err);
        // Garantir que a UI continue funcional
        await generateAvailableSlots([]);
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    }

    fetchBookedSlots();

    return () => {
      isMounted = false;
    };
  }, [selectedDate, dayConfig]);

  return {
    availableSlots,
    isLoading,
    error
  };
}